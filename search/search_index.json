{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mimosa Language Documentation","text":"<p>Mimosa is a new programming language specifically targetting embedded (control) applications. It builds upon the MIMOS model of computation, therefore it describes a program as a collection of computational components (called nodes), which communicate through FIFO buffers (called channels).</p> <p>This documentations explains the syntax of the language, and shows how a MIMOS program can be simulated.</p>"},{"location":"channels/","title":"Channels","text":"<p>A channel represents a FIFO buffer, and is defined by the keyword <code>channel</code> followed by the name, the type of values it stores, and possibly a set of initial values which shall already be present in the channel at startup of the program:</p> <pre><code>channel x : bool\nchannel y : int = { 1; 2 }\n</code></pre> <p>Initial values are added to the channel left-to-right, so a node reading from channel y will first read <code>1</code>, and then <code>2</code>. </p>"},{"location":"installation/","title":"Installation","text":"<p>First, you need to download/clone the Mimosa repository:</p> <pre><code>git clone https://github.com/nikolaushuber/mimosa.git\ncd mimosa\n</code></pre> <p>In order to use Mimosa you need to install a compatible OCaml environment. The compiler and simulator can then either be installed via dune:</p> <pre><code>dune build\ndune install\n</code></pre> <p>or via opam:</p> <pre><code>opam install . --yes\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>You can also run Mimosa inside a docker container. The easiest option is to use one of the official ocaml/opam images:</p> <pre><code>docker pull ocaml/opam:debian-11-ocaml-5.2\ndocker run -it -v ./:/home/opam/mimosa/ --name mimosa ocaml/opam:debian-11-ocaml-5.2\n</code></pre> <p>The <code>docker run</code> command creates a container from the provided image (the tag behind the <code>ocaml/opam</code> image name indicates that we would like to use version 5.2 of the OCaml compiler running on-top of Debian 11). We also instruct docker that we would like to interact with the container after it has booted (<code>-it</code>), and that it should mirror the current directory inside the container at <code>/home/opam/mimosa/</code>. The <code>--name mimosa</code> flag assigns the name <code>mimosa</code> to the container, so that we can easily restart it later.</p> <p>Once the container is up and running you can install mimosa inside it:</p> <pre><code>cd mimosa\nopam install . --yes\n</code></pre> <p>You can leave the container at any point via the <code>exit</code> command. Since we named it during creation, we can later restart and reattach to it:</p> <pre><code>docker start mimosa\ndocker attach mimosa\n</code></pre>"},{"location":"license/","title":"License","text":"<p>Copyright \u00a9 2025 Nikolaus Huber</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"nodes/","title":"Nodes","text":"<p>A node is an instantiation of a step as a process, which communicates through channels with other nodes. It defines its interface by referring to the names of channels, and the interface must be compatible with the type signature of the step it implements. It also defines the node period, which marks the periodical release pattern of the node.</p> <pre><code>node my_node implements my_step (a, b) --&gt; (c) every 100ms\n</code></pre> <p>This defines the node <code>my_node</code>, which implements the step <code>my_step</code>. The input and output patterns refer to the channels of a Mimosa program, from which inputs are read and to which outputs will be written, respectively. The period defines, when a node will try to execute. For example, the node <code>my_node</code> will try to execute at <code>0ms, 100ms, 200ms, ...</code>.</p> <p>If data is available inside all input channels, then the node can execute. In case at least one of the required inputs is not available, the node stays idle until its next release time.</p> <p>Inputs and outputs may be defined as optional (by marking the respective channel with <code>?</code>):</p> <pre><code>node print_opt implements print_opt_int (a?) --&gt; () every 100ms\nnode receive_opt implements maybe_receive_int () --&gt; (b?) every 100ms\n</code></pre> <p>If an input is marked as optional, the connected channel is inspected, and in case a value is present, it is wrapped with the <code>Some</code> constructor (see language definition) before it is handed to the implemented step, in case there is no value in the channel, <code>None</code> is used instead.</p> <p>Analogously, if an output is defined as optional, the respective return value of the step must be of optional type, and in case it is of the form <code>Some v</code>, the value <code>v</code> is written to the respective output channel, if it is <code>None</code>, no value is written out.</p>"},{"location":"overview/","title":"The Mimosa Language","text":"<p>Mimosa is a programming language specifically made for embedded (control) applications. A Mimosa program is a collection of top-level definitions, including steps, channels, and nodes. Syntactically it shares similarities with the data-flow language Lustre.</p> <ul> <li>Types</li> <li>Steps</li> <li>Channels</li> <li>Nodes</li> </ul>"},{"location":"simple_example/","title":"Guided tour through Mimosa","text":"<p>This guide walks through a very simple example of a Mimosa program, and shows how to compile and simulate it.</p>"},{"location":"simple_example/#example-program","title":"Example program","text":"<p>As a first example, we will implement the program above. It consists of three nodes, which are called rand, invert, and print.</p> <p>Node rand creates random Booleans, node invert inverts them, and node print will print them. The nodes communicate through the channels a and b, which are both FIFO buffers holding Boolean values.</p> <p>Each node will try to execute periodically, in our example all nodes have the same period of 50ms. If a node does not have input available (i.e., the channel it reads from is empty), then it will stay idle until its next release.</p> <p>Nodes are similar to threads or tasks in (real-time) operating systems. Each node implements a step, which is similar to a function in other programming languages. We will start by defining the steps for our example program.</p> <p>First, we define two step prototypes, i.e., steps for which we only define the name and type signature, but will leave the implementation to be defined externally.</p> <pre><code>step random_bool () --&gt; (_ : bool)\nstep print_bool (_ : bool) --&gt; ()\n</code></pre> <p>A step definition starts with the <code>step</code> keyword, followed by the name of the step (which must start with a lower-case letter), and then the signature, which is comprised of an input and output pattern separated by <code>--&gt;</code>.</p> <p>We could have named the formal parameters inside the input and ouput definitions (e.g., <code>() --&gt; (out : bool)</code>), however, for step prototypes we are only interested in their type signature, therefore, we do not need to invent names for the parameters (and can instead use <code>_</code> as the name).</p> <p>The only step we will implement fully in Mimosa is the invert step:</p> <pre><code>step invert (in : bool) --&gt; (out : bool)\n{\n    out = !in;\n}\n</code></pre> <p>Here, the step signature is followed by a set of equations (or in this case just one equation), which defines the output <code>out</code> as the inverted input <code>in</code>. For more information on the available operators please refer to the language definition.</p> <p>Next, we can define the two channels:</p> <pre><code>channel a : bool\nchannel b : bool\n</code></pre> <p>Each channel is given a name and a type. Optionally, a channel can also be followed by a list of initial values that shall be present inside the channel when the program starts executing. For more information on channel definitions please have a look at the language definition again.</p> <p>Finally, we can define the nodes:</p> <pre><code>node rand implements random_bool () --&gt; (a) every 50ms\nnode invert implements invert (a) --&gt; (b) every 50ms\nnode print implements print_bool (b) --&gt; () every 50ms\n</code></pre> <p>Each node has a name, a step that it implements, an interface definition, and a period. Node names are in a different namespace than steps, therefore a node can have the same name as a step (like here for <code>invert</code>). The interface refers to the channels we defined before. For each node, the interface type must be compatible with the type of the step it implements.</p> <p>Note</p> <p>Each defined channel needs to be connected once to a node input and once to a node output. Unconnected channels are flagged by the compiler.</p> <p>The full program therefore looks like this:</p> <pre><code>step random_bool () --&gt; (_ : bool)\nstep print_bool (_ : bool) --&gt; ()\n\nstep invert (in : bool) --&gt; (out : bool)\n{\n    out = !in;\n}\n\nchannel a : bool\nchannel b : bool\n\nnode rand implements random_bool () --&gt; (a) every 50ms\nnode invert implements invert (a) --&gt; (b) every 50ms\nnode print implements print_bool (b) --&gt; () every 50ms\n</code></pre> <p>Note</p> <p>The order of top-level definitions is not relevant, the compiler will order the items automatically according to their dependencies. This also means, that no two definitions of the same class (i.e., steps, nodes, or channels) can have the same name.</p> <p>We can check if the program is syntactically correct, and if it type checks, by using the <code>mimosa check</code> command. If we save the program above into a file <code>example.mim</code> we can then run</p> <pre><code>mimosa check example.mim\n</code></pre> <p>If everyone is OK, the above command will just return. You can try what happens if you change the type of one of the channels from <code>bool</code> to <code>int</code>!</p>"},{"location":"simple_example/#optional-inputs","title":"Optional inputs","text":"<p>In the example above, all nodes were running with the same period, which makes sense, since they have to wait for data to be available in their respective input buffer. However, sometimes a node may run, even if there is no available input data (for example, a control algorithm may need to compute inputs to an actuator even if there is no new command from a human operator).</p> <p>To simulate this behaviour, let's assume that the <code>print</code> node in the example above shall run at a higher frequency (e.g., with a period of 10ms), and in case there is no new input, it shall just print <code>false</code>.</p> <p>For this, we will first define a new step:</p> <pre><code>step print_opt_bool (in : bool?) --&gt; ()\n{\n    _ = print_bool (either in or false);\n}\n</code></pre> <p>Here, the input type switched from <code>bool</code> to <code>bool?</code>, which denotes an optional  Boolean type. In the definition of the step we only have one equation (and since we do not care about the return value of <code>print_bool</code> we can use the <code>_</code> pattern on the left-hand side again). The definition of the equation uses the <code>print_bool</code> step we have defined as a prototype before.</p> <p>The <code>either ... or ...</code> expression lets us unpack a value of an optional type, so <code>either in or false</code> means, that if <code>in</code> is of the form <code>Some v</code>, then <code>v</code> is returned, or if <code>in</code> is <code>None</code>, it returns <code>false</code> instead (you can think of the expression after <code>or</code> as defining a default value in case the expression after <code>either</code> is <code>None</code>).</p> <p>For more information on optional values, please have a look at the language definition again.</p> <p>With that, we can change the print node accordingly:</p> <pre><code>node print implements print_opt_bool (b?) --&gt; () every 10ms\n</code></pre> <p>An input port can be marked with <code>?</code> to declare it optional. Whenever the respective node tries to execute, it will look into the input channel, and if there is a value <code>v</code> inside it wrap it inside an optional value (i.e., <code>Some v</code>) before executing the implemented step with the wrapped input. Analogously, if the channel is empty, the step function will be executed with <code>None</code> as input. Mind the difference in types between the channel <code>b</code> (i.e., <code>bool</code>) and the input of the step <code>print_opt_bool</code> (i.e., <code>bool?</code>).</p>"},{"location":"simple_example/#simulation","title":"Simulation","text":"<p>Mimosa programs can be simulated through a deep embedding into OCaml. The <code>mimosa sim</code> command can compile a given Mimosa program into this embedding. If we run</p> <pre><code>mimosa sim example.mim\n</code></pre> <p>We get the following (slightly simplified) output:</p> <pre><code>open Mimosa.Sim_ast\n\nmodule type Extern = sig\n    val random_bool : unit -&gt; bool\n    val print_bool : bool -&gt; unit\nend\n\nmodule Simulation (E : Extern) = struct ... end\n</code></pre> <p>First, a module type <code>Extern</code> is defined, which describes the signatures of the OCaml functions we need to implement for the step prototypes. <code>Simulation</code> is a functor (a function that takes a module as input and returns a new module), which given a module of type <code>Extern</code> defines a module which can then run the simulation.</p> <p>This means, that the code produced by <code>mimosa sim</code> can be used both for defining unit tests, as well as for interactive simulation, depending on how the <code>Extern</code> module is implemented.</p> <p>For a first try, we can implement the module in the following way:</p> <pre><code>module E : Extern = struct\n  let random_bool = Random.bool\n  let print_bool b = print_string (if b then \"t \" else \"f \")\nend\n\nmodule Simulation = Simulation (E)\n\nlet _ =\n    Random.self_init ();\n    let sim = Simulation.init () in\n    exec sim 400;\n    print_newline ()\n</code></pre> <p>This implements the external functions through functions from the OCaml standard library. We can then instantiate the <code>Simulation</code> functor with these functions, and finally create a simulation run <code>sim</code> by calling <code>Simulation.init ()</code> and executing it for 400ms. When the above simulation is run, 6 random Booleans should be printed to the terminal (it takes 100ms  for the first value to reach the print node).</p> <p>This example is also implemented in the project repository under <code>/examples/minimal</code>. For details on how to run the above code, please refer to that  directory (in particular to the README).</p>"},{"location":"steps/","title":"Steps","text":"<p>Steps are the Mimosa equivalent to functions in other languages, they are elementary units of computation (specifically, they do not have any notion of time):</p> <pre><code>step add (a, b) --&gt; c\n{\n    c = a + b;\n}\n</code></pre> <p>A step definition starts with the keyword step, followed by the name of the step (which must start with a lowercase letter), followed by the inputs and outputs separated by the <code>--&gt;</code> keyword.</p> <p>Following the signature is the body of the step definition, which is a collection of equations. Intermediate variables may be defined:</p> <pre><code>...\n    tmp = a + b;\n    c = tmp;\n...\n</code></pre> <p>and the order of equations is not important, so it could equivalently be written as</p> <pre><code>...\n    c = tmp;\n    tmp = a + b;\n...\n</code></pre> <p>The compiler will automatically order the equations according to their dependencies, cyclic dependencies lead to a compile-time error.</p> <p>In the example above, we did not use any type annotations. If preferred, they can be added explicitly:</p> <pre><code>step add (a : int, b : int) --&gt; (c : int)\n{\n    c = a + b;\n}\n</code></pre> <p>It is possible to define only the name and type signature of a step, which is then called a step prototype:</p> <pre><code>step print_int (_ : int) --&gt; ()\n</code></pre> <p>These step prototypes must later be defined externally.</p>"},{"location":"steps/#patterns","title":"Patterns","text":"<p>Patterns appear at multiple places in a Mimosa program. They define the input and output of each step, and are also used as the left-hand side of equations.</p> <p>The basic pattern is just a variable pattern, to which an expression can be bound. Nested patterns are provided by tuple patterns.</p> <p>Examples:</p> <pre><code>x = 1;\nz, y = 2, 3;\n...\n</code></pre> <p>A special pattern is the wildcard or any pattern: <code>_</code>. It is useful, when we do not care about the result of a computation, or if we do not want to give a name to a parameter (as for example in the step prototype shown before).</p>"},{"location":"steps/#expressions","title":"Expressions","text":""},{"location":"steps/#constants","title":"Constants","text":"<p>There are four different families of constants available in Mimosa:</p> <ul> <li>Unit: <code>()</code></li> <li>Integer: <code>1</code>, <code>-3</code>, ...</li> <li>Float: <code>1.4</code>, <code>0.6</code>, ...</li> <li>Boolean: <code>true</code>, <code>false</code></li> </ul>"},{"location":"steps/#variables","title":"Variables","text":"<p>Expressions can refer to other named expressions by their name:</p> <pre><code>x = ...;\ny = x;\n</code></pre>"},{"location":"steps/#tuples","title":"Tuples","text":"<p>Tuples are build inductively by using <code>,</code> between sub-expressions:</p> <pre><code>1, x, 5.0\n</code></pre>"},{"location":"steps/#arithmetic-logic-and-comparison-operators","title":"Arithmetic, logic, and comparison operators","text":"<p>Mimosa offers the standard set of arithmetic and logic operators, which are common in other programming languages as well. Similar to OCaml, certain operators exist in two flavours, one for integers, and one for floats:</p> <ul> <li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>: integer arithmetic</li> <li> <p><code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>: floating point arithmetic</p> </li> <li> <p><code>&amp;&amp;</code>: and</p> </li> <li><code>||</code>: or</li> <li><code>=&gt;</code>: implies</li> <li> <p><code>!</code>: not</p> </li> <li> <p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>: integer comparison</p> </li> <li> <p><code>&lt;.</code>, <code>&lt;=.</code>, <code>&gt;=.</code>, <code>&gt;.</code>: floating point comparison</p> </li> <li> <p><code>==</code>, <code>!=</code>: polymorphic comparison</p> </li> </ul> <p>The following table lists the precedence level of all operators from lowest to highest:</p> Operator Associativity <code>=&gt;</code> left <code>||</code> left <code>&amp;&amp;</code> left <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&gt;</code> <code>&lt;.</code> <code>&lt;=.</code> <code>&gt;=.</code> <code>&gt;.</code> <code>==</code> <code>!=</code> left <code>!</code> right <code>+</code> <code>-</code> <code>+.</code> <code>-.</code> left <code>*</code> <code>/</code> <code>*.</code> <code>/.</code> left <code>?</code> <code>-</code> <code>-.</code> (unary negate) right"},{"location":"steps/#memory-operators","title":"Memory operators","text":"<p>As each expression semantically represents a (possible infinite) sequence of values, there are special operators which shift these sequences, thereby allowing to define memory.</p> <p>The <code>pre</code> operator allows referring to the previous value of a sequence. This introduces an undefined value at the first cycle, which can be removed by using the initialization operator <code>-&gt;</code>:</p> <pre><code>x = 0 -&gt; pre y\n</code></pre> <p>Similarly to <code>-&gt;</code>, the <code>fby</code> operator also allows to prepend a sequence by an initial element, however, it delays the evaluation of the second argument.</p> <p>Assuming the variable <code>x</code> represents the sequence <code>1, 2, 3, 4, ...</code>, then <code>0 -&gt; x</code> represents <code>0, 2, 3, 4, ...</code> while <code>0 fby x</code> represents <code>0, 1, 2, 3, 4, ...</code>.</p> <p>Both <code>-&gt;</code> and <code>fby</code> are right associative, and have a lower precedence than any of the arithmetic, logic, and comparison operators. <code>pre</code> is right associative and has the highest precedence of any operator in Mimosa.</p> <p>Note</p> <p>Each sequence in a Mimosa has an initialization type, which is either initialized or uninitialized. There is a dedicated analysis pass inside the Mimosa compiler, making sure that the undefined value at the beginning of uninitialized sequences has no impact on the output of the computation. It is safest, to always use a <code>pre</code> together with a corresponding <code>-&gt;</code>.</p>"},{"location":"steps/#step-application","title":"Step Application","text":"<p>A step can be used inside another step through a step application:</p> <pre><code>step add (a, b) --&gt; c\n{\n    c = a + b;\n}\n\nstep add2 x --&gt; y\n{\n    y = add (x, 2);\n}\n</code></pre> <p>Note</p> <p>The order of step definitions in a file is irrelevant, the compiler will order them according to their dependencies. Steps cannot call themselves recursively, and cyclic dependencies between steps are flagged as an error by the compiler.</p> <p>Note</p> <p>For a step application, the input argument must always be initialized. For example, <code>add2 (pre x)</code> will result in a compile error, <code>add2 (0 -&gt; pre x)</code> is accepted (assuming that <code>x</code> refers to an initialized sequence).</p>"},{"location":"steps/#conditionals","title":"Conditionals","text":"<p>The <code>if ... then ... else ...</code> construct can be used to express conditional execution. Different to Lustre, in Mimosa only one branch is evaluated.</p> <p>Note</p> <p>Each branch of a conditional must be initialized. For example <code>if c then</code>pre x<code>else y</code> will result in a compile error, <code>if c then 0 -&gt; pre x else y</code> is accepted (assuming that <code>c</code>, <code>x</code>, and <code>y</code> refer to initialized sequences).</p>"},{"location":"steps/#optionals","title":"Optionals","text":"<p>Optional expressions can be formed through the constructors <code>None</code> and <code>Some</code>: </p> <pre><code>x = None;\ny = Some 2;\n</code></pre> <p>Optionals can be deconstructed through an <code>either ... or ...</code> expression. This expression tries to evaluate the first sub-expression to <code>Some v</code> and then return <code>v</code>, otherwise (in case the first expression is <code>None</code>), evaluates the second expression.</p> <p>So, for example, <code>either (Some 2) else 3</code> evaluates to <code>2</code>, while <code>either None else 3</code> evaluates to <code>3</code>.</p> <p>Note</p> <p>Both sub-expressions of <code>either ... or ...</code> must be initialized.</p>"},{"location":"types/","title":"Types","text":"<p>Mimosa implements a Hindley-Milner-style type system, which supports type inference, so that type annotations are, for the most part, not necessary. They can of course still be given, as shown in some of the examples here.</p> <p>Mimosa has 4 inbuilt basic types: <code>unit</code>, <code>bool</code>, <code>int</code>, <code>float</code>. In addition to these basic types, it has two higher-order type constructors, one for tuples, and one for optionals.</p> <p>A tuple type is defined with the <code>*</code> type operator: <code>bool * int</code>, <code>bool * (float * int)</code>, ...</p> <p>Optional types are defined with the postfix <code>?</code> type operator: <code>int?</code>, <code>(bool * int)?</code>, ...</p>"}]}